# Level 3

Using the Async module to control asynchronous flow


## Node's concurrency model

Threads:

![IO Threads](images/io-threads.png)


Even Loop:

![IO Threads](images/io-node.png)


Benefits:

![Event Loop comparison](images/eventloop-comparison.png)


## Async flow control

Uses the callback pattern:

function with signature `(err, result)`  


## Chaining

```js
module.exports = function(cb) {
  op1(function(err, result1) {
    if (err) {
      return cb(err);
    }
    op2(function(err, result2) {
      if (err) {
        return cb(err);
      }
      op3(cb);
    }); 
  });    
}
```

Problems with this approach:

* duplicate error handling
* callback spaghetti


## One solution

async


## Install

```
$ npm install async
```


## Use

```js
var async = require('async');
```


### Chaining

```js
async.series(functions, cb);
```


### Example

```js
async.series([
  function(cb) {
    fs.mkdir(dir, cb);
  },
  function(cb) {
    fs.writeFile(path, content, cb);
  }
], function(err) {
  if (err) {
    console.error('oops:', err);
  }
  else {
    console.log('all done!');
  }
});
```



## Exercise 3.1

* Create a module exporting a function
* with the signature `(filepath, cb)`
* that uses `async.series`
* that does the following:
  - Open a file
  - wait 1 second
  - writes the current timestamp to that file + '\n'
  - waits 1 second
  - writes the current timestamp to that file + '\n'
  - closes the file


[one solution](code/03/async-series.js)

```js
var async = require('async');
var fs = require('fs');

module.exports = function(path, cb) {
  var file;

  async.series([

      function open(cb) {
        fs.open(path, 'a', function(err, fd) {
          file = fd;
          cb(err);
        });
      },

      function wait(cb) {
        setTimeout(cb, 1e3);
      },

      function writeTimestamp(cb) {
        fs.write(file, Date.now() + '\n', cb);
      },

      function wait(cb) {
        setTimeout(cb, 1e3);
      },

      function writeTimestamp(cb) {
        fs.write(file, Date.now() + '\n', cb);
      },

      function close(cb) {
        fs.close(file, cb);
      }

    ], cb);
};
```



## Exercise 3.2

Create a new version of the previous module that minimizes the lines of code and maximizes readability.


[one solution](code/03/async-series-2.js)

```js
var async = require('async');
var fs = require('fs');

function wait(secs) {
  return function(cb) {
    setTimeout(cb, secs * 1e3);
  };
}

module.exports = function(path, cb) {
  var file;

  function writeTimestamp(cb) {
    fs.write(file, Date.now() + '\n', cb);
  }

  async.series([
      function open(cb) {
        fs.open(path, 'a', function(err, fd) {
          file = fd;
          cb(err);
        });
      },
      wait(1),
      writeTimestamp,
      wait(1),
      writeTimestamp
    ], cb);
};
```



## async.waterfall

`async.waterfall` is like `async.series`, but it passes the results from the previous function into the next.



### Exercise 3.3

* Using `async.waterfall`
* create a module that exports a function
* with the signature `(url, path, cb)`
* this function does the following:
  - makes an HTTP GET request to the given url
  - saves the response headers into a file in `path`


[one solution](code/03/fetch-waterfall.js)

```js
var async = require('async');
var http = require('http');
var fs = require('fs');

function get(url) {
  return function(cb) {
    var req = http.get(url, function(res) {
      cb(null, res.headers);
    });

    req.once('error', cb);
  }
}

module.exports = function(url, path, cb) {

  async.waterfall([
      get(url),
      function(headers, cb) {
        cb(null, JSON.stringify(headers));
      },
      fs.writeFile.bind(fs, path)
    ], cb);
};
```



### Exercise 3.4

Redo the exercise 3.2, but this time get rid of global state by using `async.waterfall`.


[one solution](code/03/async-waterfall.js)

```js
var async = require('async');
var fs = require('fs');

function wait(secs) {
  return function(file, cb) {
    console.log(arguments);
    setTimeout(cb, secs * 1e3, null, file);
  };
}

module.exports = function(path, cb) {

  function writeTimestamp(file, cb) {
    fs.write(file, Date.now() + '\n', function(err) {
      cb(err, file);
    });
  }

  async.waterfall([
      fs.open.bind(fs, path, 'a'),
      wait(1),
      writeTimestamp,
      wait(1),
      writeTimestamp
    ], cb);
};
```